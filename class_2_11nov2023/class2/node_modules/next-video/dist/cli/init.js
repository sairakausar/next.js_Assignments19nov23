import { confirm, input } from "@inquirer/prompts";
import chalk from "chalk";
import os from "node:os";
import { exec } from "node:child_process";
import { access, mkdir, stat, readFile, writeFile, appendFile } from "node:fs/promises";
import path from "node:path";
import log from "../logger.js";
import { checkPackageJsonForNextVideo, updateTSConfigFileContent } from "./lib/json-configs.js";
import updateNextConfigFile from "./lib/next-config.js";
const TYPES_FILE_CONTENTS = `/// <reference types="next-video/video-types/global" />
`;
const DEFAULT_DIR = "videos";
const DEV_SCRIPT = "& npx next-video sync -w";
const gitIgnoreContents = (videosDir) => `
# next-video
${videosDir}/*
!${videosDir}/*.json
!${videosDir}/*.js
!${videosDir}/*.ts
public/_next-video
`;
async function preInitCheck(dir) {
  try {
    await stat(dir);
    return false;
  } catch (err) {
    if (err.code === "ENOENT") {
      return true;
    }
    throw err;
  }
}
async function checkVersionManager() {
  try {
    await access("package-lock.json");
    return "npm";
  } catch {
  }
  try {
    await access("yarn.lock");
    return "yarn";
  } catch {
  }
  try {
    await access("pnpm-lock.yaml");
    return "pnpm";
  } catch {
  }
  return void 0;
}
function execPromise(command2) {
  return new Promise((resolve, reject) => {
    exec(command2, (err, stdout, stderr) => {
      if (err) {
        return reject(err);
      }
      return resolve(stdout);
    });
  });
}
async function createVideoDir(dir) {
  const fullPath = path.join(process.cwd(), dir);
  await mkdir(fullPath, { recursive: true });
  await appendFile(".gitignore", gitIgnoreContents(dir));
  return;
}
async function createTSFile(filePath) {
  await writeFile(filePath, TYPES_FILE_CONTENTS);
  return;
}
async function updateTSConfigFile(tsConfigPath) {
  const configContents = await readFile(tsConfigPath, "utf-8");
  const updatedContents = updateTSConfigFileContent(configContents);
  return writeFile(tsConfigPath, updatedContents);
}
const command = "init [dir]";
const desc = "Initializes next-video in a project.";
function builder(yargs) {
  return yargs.options({
    dir: {
      alias: "d",
      describe: "The directory you want to initialize next-video with.",
      type: "string"
    },
    force: {
      alias: "f",
      describe: "Continue with initialization even if the chosen directory already exists.",
      type: "boolean",
      default: false
    },
    typescript: {
      alias: "ts",
      describe: "Initialize next-video for use with TypeScript.",
      type: "boolean",
      default: false
    },
    tsconfig: {
      describe: "Automatically update your tsconfig.json file to include the next-video types.",
      type: "boolean",
      default: false
    },
    devscript: {
      describe: `Automatically update your package.json to add the watch command to your dev script.`,
      type: "boolean",
      default: false
    }
  });
}
async function handler(argv) {
  let baseDir = argv.dir;
  let packageInstalled = false;
  let ts = argv.typescript;
  let updateTsConfig = argv.tsconfig;
  let updateDevScript = argv.devscript;
  let changes = [];
  try {
    packageInstalled = await checkPackageJsonForNextVideo("./package.json");
  } catch (err) {
    if (err.code === "ENOENT") {
      log.error(
        `Failed to find/read a local package.json. Double check that you're running this from the root of your project.`
      );
      return;
    }
    console.log(err);
  }
  if (!packageInstalled) {
    const install = await confirm({
      message: `It doesn't look like ${chalk.magenta.bold(
        "next-video"
      )} is installed in this project. Would you like to install it now?`,
      default: true
    });
    if (install) {
      const manager = await checkVersionManager();
      if (!manager) {
        log.error("Failed to detect a package manager. Please install next-video manually and re-run this command.");
        log.info("For example, in NPM: npm install --save-dev next-video");
        return;
      }
      log.info("Detected package manager:", manager);
      log.info("Installing next-video...");
      try {
        if (manager === "npm") {
          await execPromise("npm install next-video");
        } else if (manager === "yarn") {
          await execPromise("yarn add next-video");
        } else if (manager === "pnpm") {
          await execPromise("pnpm add next-video");
        }
        log.info("Successfully installed next-video!");
      } catch (err) {
        log.error("Failed to install next-video:", err);
      }
    } else {
      log.info("Make sure to add next-video to your package.json manually");
    }
  }
  if (!baseDir) {
    baseDir = await input({ message: "What directory should next-video use for video files?", default: DEFAULT_DIR });
  }
  const shouldContinue = await preInitCheck(baseDir);
  if (!argv.force && !shouldContinue) {
    log.warning("Directory already exists:", baseDir);
    log.info("If you'd like to proceed anyway, re-run with --force");
    return;
  }
  await createVideoDir(baseDir);
  changes.push([log.add, `Created ${baseDir} directory.`]);
  if (!ts) {
    ts = await confirm({ message: "Is this a TypeScript project?", default: true });
  }
  if (ts) {
    await createTSFile(path.join(process.cwd(), "video.d.ts"));
    changes.push([log.add, `Created video.d.ts.`]);
  }
  if (ts && !updateTsConfig) {
    updateTsConfig = await confirm({ message: "Update tsconfig.json to include next-video types?", default: true });
  }
  if (updateTsConfig) {
    try {
      await updateTSConfigFile(path.join(process.cwd(), "tsconfig.json"));
      changes.push([log.add, `Updated tsconfig.json to include next-video types.`]);
    } catch (err) {
      changes.push([log.error, 'Failed to update tsconfig.json, please add "video.d.ts" to the include array']);
    }
  } else if (ts) {
    changes.push([log.info, `Add ${chalk.underline("video.d.ts")} to the includes array in tsconfig.json.`]);
  }
  const cmd = await isCmd();
  if (!cmd && !updateDevScript) {
    updateDevScript = await confirm({
      message: `Update package.json to add the watch command to your dev script?`,
      default: true
    });
  }
  if (!cmd && updateDevScript) {
    try {
      const devScript = (await execPromise(`npm pkg get scripts.dev`))?.trim().slice(1, -1);
      if (devScript && !devScript.includes(DEV_SCRIPT)) {
        await execPromise(`npm pkg set scripts.dev='${devScript} ${DEV_SCRIPT}'`);
      }
      changes.push([log.add, `Updated package.json to add the watch command to your dev script.`]);
    } catch (err) {
      changes.push([log.error, `Failed to update package.json, please add "${DEV_SCRIPT}" to your dev script.`]);
    }
  }
  try {
    const update = await updateNextConfigFile("./", { folder: baseDir });
    if (update) {
      changes.push([log.add, `Updated ${update.configPath} to include next-video.`]);
    }
  } catch (e) {
    if (e.error === "not_found") {
      changes.push([
        log.error,
        "No next.config.js or next.config.mjs file found. Please add next-video to your config manually."
      ]);
    } else if (e.error === "already_added") {
      changes.push([log.info, "It seems like next-video is already added to your Next Config"]);
    } else {
      changes.push([log.error, "Failed to update next.config.js, please add next-video to your config manually."]);
    }
  }
  log.success(`${chalk.magenta.bold("next-video")} initialized!`);
  changes.forEach(([loggerFn, change]) => loggerFn(change));
  log.info("");
  log.info(`NEXT STEP: Set up remote storage`);
  log.info(chalk.magenta.bold("https://next-video.dev/docs#remote-storage-and-optimization"));
  log.info("");
}
async function isCmd() {
  if (os.platform() === "win32") {
    try {
      await execPromise(`ls`);
    } catch (err) {
      return true;
    }
  }
  return false;
}
export {
  builder,
  command,
  desc,
  handler
};
