import fs from "node:fs/promises";
import path from "node:path";
import chalk from "chalk";
import Mux from "@mux/mux-node";
import { fetch as uFetch } from "undici";
import sharp from "sharp";
import { updateAsset } from "../assets.js";
import log from "../logger.js";
let mux;
function initMux() {
  mux = new Mux();
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function pollForAssetReady(filePath, asset) {
  if (!asset.externalIds?.assetId) {
    log.error("No assetId provided for asset.");
    console.error(asset);
    return;
  }
  initMux();
  const assetId = asset.externalIds?.assetId;
  const muxAsset = await mux.video.assets.retrieve(assetId);
  const playbackId = muxAsset.playback_ids?.[0].id;
  let updatedAsset = asset;
  if (asset.externalIds?.playbackId !== playbackId) {
    updatedAsset = await updateAsset(filePath, {
      externalIds: {
        playbackId
      }
    });
  }
  if (muxAsset.status === "errored") {
    log.error(log.label("Asset errored:"), filePath);
    log.space(chalk.gray(">"), log.label("Mux Asset ID:"), assetId);
    return updateAsset(filePath, {
      status: "error",
      error: muxAsset.errors
    });
  }
  if (muxAsset.status === "ready") {
    let blurDataURL;
    try {
      blurDataURL = await createThumbHash(`https://image.mux.com/${playbackId}/thumbnail.png?width=100&height=100`);
    } catch (e) {
      log.error("Error creating a thumbnail hash.");
    }
    log.success(log.label("Asset is ready:"), filePath);
    log.space(chalk.gray(">"), log.label("Playback ID:"), playbackId);
    return updateAsset(filePath, {
      status: "ready",
      externalIds: {
        playbackId
      },
      blurDataURL
    });
  } else {
    await sleep(1e3);
    return pollForAssetReady(filePath, updatedAsset);
  }
}
async function pollForUploadAsset(filePath, asset) {
  if (!asset.externalIds?.uploadId) {
    log.error("No uploadId provided for asset.");
    console.error(asset);
    return;
  }
  initMux();
  const uploadId = asset.externalIds?.uploadId;
  const muxUpload = await mux.video.uploads.retrieve(uploadId);
  if (muxUpload.asset_id) {
    log.info(log.label("Asset is processing:"), filePath);
    log.space(chalk.gray(">"), log.label("Mux Asset ID:"), muxUpload.asset_id);
    const processingAsset = await updateAsset(filePath, {
      status: "processing",
      externalIds: {
        assetId: muxUpload.asset_id
      }
    });
    return pollForAssetReady(filePath, processingAsset);
  } else {
    await sleep(1e3);
    return pollForUploadAsset(filePath, asset);
  }
}
async function uploadLocalFile(asset) {
  if (!asset.originalFilePath) {
    log.error("No filePath provided for asset.");
    console.error(asset);
    return;
  }
  initMux();
  if (asset.status === "ready") {
    return;
  } else if (asset.status === "processing") {
    log.info(log.label("Asset is already processing. Polling for completion:"), asset.originalFilePath);
    return pollForAssetReady(asset.originalFilePath, asset);
  } else if (asset.status === "uploading") {
    log.info(log.label("Resuming upload:"), asset.originalFilePath);
  }
  const src = asset.originalFilePath;
  if (src && /^https?:\/\//.test(src)) {
    return uploadRequestedFile(asset);
  }
  let upload;
  try {
    upload = await mux.video.uploads.create({
      cors_origin: "*",
      // @ts-ignore
      new_asset_settings: {
        playback_policy: ["public"]
      }
    });
  } catch (e) {
    log.error("Error creating a Mux Direct Upload");
    console.error(e);
    return;
  }
  await updateAsset(src, {
    status: "uploading",
    externalIds: {
      uploadId: upload.id
      // more typecasting while we use the beta mux sdk
    }
  });
  const filePath = path.join(src);
  const fileDescriptor = await fs.open(filePath);
  const fileStats = await fileDescriptor.stat();
  const stream = fileDescriptor.createReadStream();
  log.info(log.label("Uploading file:"), `${filePath} (${fileStats.size} bytes)`);
  try {
    await uFetch(upload.url, {
      method: "PUT",
      // @ts-ignore
      body: stream,
      duplex: "half"
    });
    stream.close();
    await fileDescriptor.close();
  } catch (e) {
    log.error("Error uploading to the Mux upload URL");
    console.error(e);
    return;
  }
  log.success(log.label("File uploaded:"), `${filePath} (${fileStats.size} bytes)`);
  const processingAsset = await updateAsset(src, {
    status: "processing"
  });
  return pollForUploadAsset(src, processingAsset);
}
async function uploadRequestedFile(asset) {
  if (!asset.originalFilePath) {
    log.error("No URL provided for asset.");
    console.error(asset);
    return;
  }
  initMux();
  if (asset.status === "ready") {
    return;
  } else if (asset.status === "processing") {
    log.info(log.label("Asset is already processing. Polling for completion:"), asset.originalFilePath);
    return pollForAssetReady(asset.originalFilePath, asset);
  }
  const src = asset.originalFilePath;
  const assetObj = await mux.video.assets.create({
    // @ts-ignore
    input: [{
      url: asset.originalFilePath
    }],
    playback_policy: ["public"]
  });
  log.info(log.label("Asset is processing:"), src);
  log.space(chalk.gray(">"), log.label("Mux Asset ID:"), assetObj.id);
  const processingAsset = await updateAsset(src, {
    status: "processing",
    externalIds: {
      assetId: assetObj.id
    }
  });
  return pollForAssetReady(src, processingAsset);
}
async function createThumbHash(imgUrl) {
  const response = await uFetch(imgUrl);
  const buffer = await response.arrayBuffer();
  const { data, info } = await sharp(buffer).raw().ensureAlpha().toBuffer({ resolveWithObject: true });
  const { rgbaToThumbHash, thumbHashToDataURL } = await import("thumbhash");
  const hash = rgbaToThumbHash(info.width, info.height, data);
  return thumbHashToDataURL(hash);
}
export {
  createThumbHash,
  uploadLocalFile,
  uploadRequestedFile
};
